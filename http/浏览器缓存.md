http://web.jobbole.com/84888/

浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器

# 浏览器的缓存命中原理

# 分类：强缓存、协商缓存

1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。

比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；

2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；

**共同点 & 不同点**

共同点：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；

区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。

4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。

# 强缓存

### 强缓存的原理

当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache

强缓存是利用响应头中`Expires`或者`Cache-Control`实现的，它们都用来表示资源在客户端缓存的有效期。

- Expires

服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。

- Cache-Control

一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000

`Expires` 和 `Cache-Control`可以只启用一个，也可以同时启用，当response header中，`Expires`和`Cache-Control`同时存在时，`Cache-Control`优先级高于`Expires`

### 强缓存的应用

强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。
通常的做法是，为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了2026年。

然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题。这个问题已经有成熟的解决方案：

##### [大公司里怎样开发和部署前端代码？](https://www.zhihu.com/question/20790576)

- 配置超长时间的本地缓存  —— 节省带宽，提高性能

- 采用内容摘要作为缓存更新依据  —— 精确的缓存控制

- 静态资源CDN部署    —— 优化网络请求

- 变更资源发布路径实现非覆盖式发布  —— 平滑升级

##### 覆盖式发布 vs 非覆盖式发布

- 覆盖式发布: 

通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源: `a.css?v=1.0.0`

- 非覆盖式发布: 用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件

先全量部署静态资源，再灰度部署页面

# 协商缓存的原理

当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的`http`状态为304并且会显示一个`Not Modified`的字符串，

比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的

只要看到`304`的状态码和`Not Modified`的字符串就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源.

协商缓存是利用的是`Last-Modified`，`If-Modified-Since` 和 `ETag`、`If-None-Match`这**两对**Header来管理的

- `Last-Modified`，`If-Modified-Since`的控制缓存的原理：**最后修改时间**

1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间

2. 浏览器再次跟服务器请求这个资源时，在request的header上加上`If-Modified-Since`的header，这个header的值就是上一次请求时返回的Last-Modified的值

3. 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，
如果没有变化则返回`304 Not Modified`，但是不会返回资源内容；如果有变化，就正常返回资源内容。
当服务器返回`304 Not Modified`的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header

4. 浏览器收到304的响应后，就会从缓存中加载资源。

5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。

**问题**：
【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是**最后修改时间却没有变化**的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。

所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】

- `ETag`、`If-None-Match` 原理：资源唯一标识

1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题

2. 浏览器再次跟服务器请求这个资源时，在request的header上加上`If-None-Match`的header，这个header的值就是上一次请求时返回的ETag的值：

3. 服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化

4. 浏览器收到304的响应后，就会从缓存中加载资源。

### 协商缓存的管理

协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】

如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。

【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意:

分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；

分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）

协商缓存需要配合强缓存使用，因为如果不启用强缓存的话，协商缓存根本没有意义

# 浏览器行为对缓存的影响

如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，
如果强缓存命中则直接读取缓存，
如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，
如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。
这是默认的处理方式，这个方式可能被浏览器的行为改变：

1）当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；

2）当f5刷新网页时，跳过强缓存，但是会检查协商缓存