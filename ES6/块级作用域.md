块级作用域
========

ES5 只有**全局作用域**和**函数作用域**，没有块级作用域

这带来很多不合理的场景:

1. 第一种场景，内层变量可能会覆盖外层变量

eg:
```
var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    // 变量提升，导致内层的tmp变量覆盖了外层的tmp变量
    var tmp = 'hello world';
  }
}

f(); // undefined
```

2. 第二种场景，用来计数的循环变量泄露为全局变量。


# 块级作用域

不再需要使用**立即执行函数表达式（IIFE）**来创建一个局部作用域

// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

**替代写法：**
// 块级作用域写法
{
  let tmp = ...;
  ...
}

### 块级作用域与函数声明

1. ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明；但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数


2. ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的**行为类似于let，在块级作用域之外不可引用**

如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式：

> 1. 允许在块级作用域内声明函数。
>
> 2. 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
>
> 3. 同时，函数声明还会提升到所在的块级作用域的头部。


注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。

根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。

**解决：**

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成**函数表达式**，而不是函数声明语句。

eg:

```
// 函数声明语句
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
```