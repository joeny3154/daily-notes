# vue 组件缓存

keep-alive组件

<keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。正如之前所说的，如果不使用keep-alive，每次切换到一个路由下的组件时，如果有请求，就会发起ajax请求，即在离开这个组件时就已经销毁了这个组件。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。　

使用keep-alive固然是好，但是并不是所有情况下都适合使用keep-alive，因为keep-alive意味着页面省去了重新挂载渲染，这貌似很好，但是这更意味着我们没法使用 created updated mounted 这些生命周期钩子函数了，所以只有在固定不变的地方我们才建议使用keep-alive， 否则不适用

暂时没有直接支持。不过现在你可以在meta里定义是否keepAlive来workaround。

``` js
<keep-alive>
    <router-view v-if="$route.meta.keepAlive"></router-view>
</keep-alive>
<router-view v-if="!$route.meta.keepAlive"></router-view>

<!-- 增加 router.meta 属性// routes 配置 -->
export default [
  {
    path: '/',
    name: 'home',
    component: Home,
    meta: {
      keepAlive: true // 需要被缓存
    }
  }, {
    path: '/:id',
    name: 'edit',
    component: Edit,
    meta: {
      keepAlive: false // 不需要被缓存
    }
  }
]

```

# 请求数据缓存

``` js
_ajaxDoubleBuffering(path, data = {}, method = 'get', dataType = 'json') {
    data = this._mergeData(data);

    var key = this._formatDBKey(path, data, method);
    var local = new Local(key);
    var str = local.get();

    var q1 = null;
    var dbv = this._dbv;
    if (str) {
        try {
            var db = JSON.parse(str);
            if (db.dbv >= this._dbv) {
                dbv = db.dbv;
                console.log('fromDoubleBuffer', db.dbv, path);
                q1 = Q.fcall(() => db.json);
            }
        } catch (e) {
        }
    }

    var q2 = this._ajax(path, data, method, dataType).then(json => {
        if (!json.code) {
            var db = {
                dbv: dbv,
                json: json
            };
            local.set(JSON.stringify(db));
        }
        return json;
    });

    return q1 ? q1 : q2;
}

 _formatDBKey(path, data, method) {
    var ss = [];
    for (var key in data) {
        ss.push(`${key}=${data[key]}`);
    }
    return `ajax_double_buffer2:${method}:${this.apiConfig.apiUrl}${path}/{${ss.join('&')}}`;
}
```
# get post 区别

GET和POST本质上就是TCP链接，并无差别。

缓存：HTTP缓存通常只适用于idempotent request（可以理解为查询请求，也就是不更新服务端数据的请求），这也就导致了在HTTP的世界里，一般都是对Get请求做缓存，Post请求很少有缓存。

GET能被缓存，POST不能缓存 。

GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。

post（大部分实现）不可缓存。为了针对其不可缓存性

url长度限制：URL 的最大长度是 2048 个字符

# js机制

# http 请求头

- `Accept`： (A ke sai te)报文头属性告诉服务端 客户端接受什么类型的响应；`Accept:text/plain`, 客户端能够接受的响应类型仅为纯文本数据

  - `Accept-Charset`： 通知服务端可以发送的编码格式

  - `Accept-Encoding`： 通知服务端可以发送的数据压缩格式

  - `Accept-Language`： 通知服务端可以发送的语言

  - `Accept-Ranges`	可以请求网页实体的一个或者多个子范围字段	Accept-Ranges: bytes

- `Cookie`: 客户端的Cookie就是通过这个报文头属性传给服务端; eg: `Cookie: $Version=1; Skin=new;jsessionid=5F4771183629C9834F8382E23BE13C4C`

- `Referer`: 引荐人(rui fo er)，表示这个请求是从哪个URL过来的，比如在google搜索页面进入一个商家的广告，鼠标一点发送一个请求报文到商家的网站，这个请求报文的`Referer`报文头属性值就是`http://www.google.com`。网页监控软件帮你监控流量，得到全国访问客户来源的分布等情况的报表和图表，其原理就是通过这个`Referer`及其它一些HTTP报文头工作的

- `Host`： 接受请求的服务器地址，可以是IP:端口号，也可以是域名 如：`blog.csdn.net`

- `Cache-Control`: 对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的
如以下设置，相当于让服务端将对应请求返回的响应内容不要在客户端缓存：`Cache-Control: no-cache`

- `User-Agent`： 发送请求的应用程序名称 `User-Agent: Mozilla/5.0 (Linux; X11)`

- `Content-Length`	请求的内容长度	`Content-Length: 348`

- `Content-Type`	请求的与实体对应的MIME信息	`Content-Type: application/x-www-form-urlencoded`

- `If-Modified-Since`	如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码	`If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT`

- `If-None-Match`	如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变	`If-None-Match: “737060cd8c284d8af7ad3082f209582d”`


# canvas css设置宽度

canvas的默认宽高为300px*150px，在css中设置canvas的宽高，实际上是把canvas在300px*150px的基础上进行了拉伸。所以绘制出来的图像会发生变形

方案1：

`<canvas id="canvas" width="300" height="300"></canvas> `

方案2：

``` js
document.getElementById("canvas").width = 600;  
document.getElementById("canvas").height = 600;  
```

`context.globalCompositeOperation = 'destination-out'`

# 清除未使用模块


# 观察者模式

``` js
// 首先定义一个可观察对象
var Observable = function() {  
   //只有一个用于收集订阅者的对象,这个地方要写成公共对象
   // 不能用var subscribers = {}, 这样会写成私有对象
   this.subscribers = {};  
} ;
// Observable 对象原型上上的3个方法: subscribe, unsubscribe, publish
Observable.prototype = {
  constructor: Observable,

  // subscribe @param1 type  @param2 fn
  subscribe: function(type, fn) {
   
  // 首先查看对象subscribers上是否存在type属性
    if (!this.subscribers[type]) {
      this.subscribers[type] = [];
    }
    // 将订阅者加入到 subscribers 中
    // subscriber is just a function，订阅者仅仅是一个函数而已
    this.subscribers[type].push(fn);
  },
    // unsubscribe 取消订阅 @param1 type  @param2 fn
  unsubscribe: function(type, fn) {
    // 先判断subscribers中存不存在type这个属性，不存在直接返回
    if (!this.subscribers[type]) {
        return;
    }
    // 存在type,将要取消订阅的订阅者找出，从订阅者名单中删除掉
    var listeners = this.subscribers[type], i, len = listeners.length;
    for (i = 0; i < len; i++) {
        if (listeners[i] === fn) {
            // 将取消订阅的观察者observer移除
            listeners.splice(i, 1);
            return;
        }
    }
  },
  // publish: 发布 @param1 type  @param2 eventArgs(事件信息)
  publish: function(type, event) {
   // 判断观察者对象集合subscribers中存不存在type属性，不存在则表示为订阅，直接返回
   if (!this.subscribers[type]) {
      return;
   }
   // 先判断对象event中存不存在type这个属性，不存在就创建该属性
    if (!event[type])  {
        event[type] = type;
    }
   // 找到该事件对应的观察者，并发布通知
    var  listeners = this.subscribers[type],
          i,
          len = listeners.length;
    for (i = 0; i < len; i++) {
        listeners[i](event);
    }
  }
}

```
``` js
function Pubsub(){
    //存放事件和对应的处理方法
  this.handles = {};
}
Pubsub.prototype={
  //传入事件类型type和事件处理handle
  on: function (type, handle) {
    if(!this.handles[type]){
        this.handles[type] = [];
    }
    this.handles[type].push(handle);
  },
  emit: function () {
      //通过传入参数获取事件类型
    var type = Array.prototype.shift.call(arguments);
    if(!this.handles[type]){
        return false;
    }
    for (var i = 0; i < this.handles[type].length; i++) {
      var handle = this.handles[type][i];
      //执行事件
      handle.apply(this, arguments);
    }
  },
  off: function (type, handle) {
    handles = this.handles[type];
    if(handles){
      if(!handle){
        handles.length = 0;//清空数组
      } else {
        for (var i = 0; i < handles.length; i++) {
            var _handle = handles[i];
            if(_handle === handle){
                handles.splice(i,1);
            }
          }
        }
    }
  }
}
```

# new 构造函数 过程

1. 创建空对象；var obj = {};

2. 设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象；
　　obj.__proto__ = ClassA.prototype;

3. 使用新对象调用函数，函数中的this被指向新实例对象：`ClassA.call(obj)`;　　//{}.构造函数();          

4. 将初始化完毕的新对象地址，保存到等号左边的变量中

# 统计实例个数

```js
var ClassA = (function () {
  var count = 0
  function ClassA (name) {
    this.name = name
    // new
    if (this instanceof ClassA) {
      console.log('this', this)
      count ++
    }
  }
  ClassA.getInstanceNumber = function () {
    console.log('count', count)
    return count
  }
  return ClassA
})()

class ClassA {
  constructor () {
    ClassA.instanceNumber = (ClassA.instanceNumber || 0) + 1
  }

  static getInstanceNumber () {
    return this.instanceNumber || 0
  }
}

```

# webpack import vs require

webpack 2 支持原生的 ES6 模块语法，意味着你可以无须额外引入 babel 这样的工具，就可以使用 import 和 export。但是注意，如果使用其他的 ES6+ 特性，仍然需要引入 babel。

通过 import 以静态的方式，导入另一个通过 export 导出的模块

由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构

`import { 'f' + 'oo' } from 'my_module';`会报错， 而require可以

import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中

这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。

const path = './' + fileName;
const myModual = require(path);
上面的语句就是动态加载，require到底加载哪一个模块，只有运行时才知道。

import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。

import 规范不允许控制模块的名称或其他属性，因为 "chunks" 只是 webpack 中的一个概念。幸运的是，webpack 中可以通过注释接收一些特殊的参数，而无须破坏规定

``` js
import(
  /* webpackChunkName: "my-chunk-name" */
  /* webpackMode: "lazy" */
  'module'
);
```
`webpackChunkName`：新 chunk 的名称。从 webpack 2.6.0 开始，[index] and [request] 占位符，分别支持赋予一个递增的数字和实际解析的文件名。
`webpackMode`：从 webpack 2.6.0 开始，可以指定以不同的模式解析动态导入。支持以下选项
https://doc.webpack-china.org/api/module-methods/#import

require: 以同步的方式检索其他模块的导出。由编译器(compiler)来确保依赖项在最终输出 bundle 中可用。

# Vue双向数据绑定的实现

vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的

`Object.defineProperty( )`设置了对象的属性，对其get和set进行重写操作

1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。

2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。

3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器

https://www.cnblogs.com/canfoo/p/6891868.html

vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者（文本节点则是作为订阅者），在收到消息后执行相应的更新操作。

compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

# react和vue有哪些不同 说说你对这两个框架的看法

Virtual DOM：改变真实的DOM状态远比改变一个JavaScript对象的花销要大得多

计算新旧Virtual DOM之间的差异并反应在真实的DOM上。计算差异的算法是高性能框架的秘密所在，React和Vue在实现上有点不同。

首先，内部实现本质上不同。React 的渲染建立在 Virtual DOM 上——一种在内存中描述 DOM 树状态的数据结构。当状态发生变化时，React 重新渲染 Virtual DOM，比较计算之后给真实 DOM 打补丁。

**Virtual DOM**

React 的 Virtual DOM 也不是不需要优化的。复杂的应用里你有两个选择：

1. 手动添加 `shouldComponentUpdate` 来避免不需要的 vdom re-render；2. Components 尽可能都用 pureRenderMixin，然后采用 Flux 结构 + Immutable.js。其实也不是那么简单的。

相比之下，Vue 由于采用依赖追踪，默认就是优化状态：你动了多少数据，就触发多少更新，不多也不少。

**双向绑定**

表单的双向绑定，说到底不过是 （value 的单向绑定 + onChange 事件侦听）的一个语法糖

JSX 在逻辑表达能力上虽然完爆模板

React 的另一个问题是：由于 DOM 更新完全交给 Virtual DOM 管理，当想要自己控制 DOM 时就有点棘手了（虽然理论上可以做到，但是这样做就本质上违背了 React 的设计思想）。如果应用需要特别的自定义 DOM 操作，特别是复杂时间控制的动画，这个限制就很讨厌。在这方面，Vue.js 更灵活。

**状态变更**

而在Vue中，则不需要使用如`setState()`之类的方法去改变它的状态，在Vue对象中，data参数就是应用中数据的保存者。

**vs 传统**

如果你的应用中，交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意，如果你更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM

# 平时用了es6的哪些特性，体验如何

- 箭头函数: 

- class语法: 相对原型、构造函数、继承更接近传统语法，它的写法能够让对象原型的写法更加清晰、面向对象编程的语法更加通俗

# let、const 区别

实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动

- ES6 声明变量的六种方法

ES5 只有两种声明变量的方法：var命令和function命令。

ES6 除了添加let和const命令，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。

- set数据结构：类似于数组，但是成员值都是唯一的

- 模板字符串

- rest参数: 获取函数的多余参数

`function add(...rest) {}`

- module


# 修饰器

类修饰器：修饰器是一个对类进行处理的函数， 修饰器函数的第一个参数，就是所要修饰的目标类。

方法的修饰：`readonly(Person.prototype, 'name', descriptor);`修饰器第一个参数是类的原型对象

# 浏览器原生支持module吗，如果支持，会带来哪些便利

- 运行时加载

``` js
// CommonJS模块
let { stat, exists, readFile } = require('fs');

// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
```
面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。

- 编译时加载/静态加载

``` js
// ES6模块
import { stat, exists, readFile } from 'fs';
```

上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。

# 介绍一下你对webpack的理解，和gulp有什么不同

webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。

gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。

虽然都是前端自动化构建工具，但看他们的定位就知道不是对等的。
gulp严格上讲，模块化不是他强调的东西，他旨在规范前端开发流程。
webpack更是明显强调模块化开发，而那些文件压缩合并、预处理等功能，不过是他附带的功能。

# webpack打包速度慢，你觉得可能的原因是什么，该如何解决

模块过多

- 开发环境不做无意义的操作

代码压缩、目录内容清理、计算文件hash、提取CSS文件

很多配置，在开发阶段是不需要去做的，我们可以区分出开发和线上的两套配置

- 选择一个合适的devtool属性值

`eval-source-map`（vue-cli dev配置使用此项选）每个模块使用 eval() 执行，并且 SourceMap 转换为 DataUrl 后添加到 eval() 中。初始化 SourceMap 时比较慢，但是会在重构建时提供很快的速度，并且生成实际的文件。行数能够正确映射，因为会映射到原始代码中。

- happypack 多线程打包

利用node提供的多线程环境，happypack 是可以多线程打包的
采用多进程去打包构建，使用方式还是蛮简单的，但并不是支持所有的loader

- dll打包

需要两个插件 DllPlugin 和 DllReferencePlugin， Dll是动态链接库的意思，实际上就是将这些npm打包生成一个JSON文件，这个文件里包含了npm包的路径对应信息

- babel-loader开启缓存

# http响应中`content-type`包含哪些内容

指定返回内容的类型，主要包括住类型/子类型

- text

text/html ： HTML格式
text/plain ：纯文本格式
text/xml ： XML格式

- image

image/gif ：gif图片格式
image/jpeg ：jpg图片格式
image/png：png图片格式
以application开头的媒体格

- application

以application开头的媒体格式类型：
application/xhtml+xml ：XHTML格式
application/xml ： XML数据格式
application/atom+xml ：Atom XML聚合格式
application/json ： JSON数据格式
application/pdf ：pdf格式
application/msword ： Word文档格式
application/octet-stream ： 二进制流数据（如常见的文件下载）
application/x-www-form-urlencoded 

# 如何取出一个数组里的图片并按顺序显示出来

# Node，Koa用的怎么样

特点是优雅、简洁、表达力强、自由度高。本身代码只有1000多行，所有功能都通过插件实现

``` js
const Koa = require('koa');
const app = new Koa();
app.listen(3000);
```
- HTTP Response 的类型

Koa 默认的返回类型是text/plain，如果想返回其他类型的内容，可以先用`ctx.request.accepts`判断，然后使用`ctx.response.type`指定返回类型

- Context 对象

Context.response.body属性就是发送给用户的内容

- 网页模板

实际开发中，返回给用户的网页往往都写成模板文件。我们可以让 Koa 先读取模板文件，然后将这个模板返回给用户
``` js
const main = ctx => {
  ctx.response.type = 'html';
  ctx.response.body = fs.createReadStream('./demos/template.html');
};
```

- 中间件

每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是next函数。只要调用next函数，就可以把执行权转交给下一个中间件

**中间件栈**:多个中间件会形成一个栈结构（middle stack），以"先进后出"（first-in-last-out）的顺序执行。

**异步中间件**:如果有异步操作（比如读取数据库），中间件就必须写成 async 函数。

``` js
const main = async function (ctx, next) {
  ctx.response.type = 'html';
  ctx.response.body = await fs.readFile('./demos/template.html', 'utf8');
};
```

- 路由

网站一般都有多个页面。通过ctx.request.path可以获取用户请求的路径，由此实现简单的路由。

koa-route 模块: 原生路由用起来不太方便，我们可以使用封装好的koa-route模块

- 静态资源

如果网站提供静态资源（图片、字体、样式表、脚本......），为它们一个个写路由就很麻烦，也没必要。koa-static模块封装了这部分的请求

``` js
const serve = require('koa-static');
const main = serve(path.join(__dirname));
app.use(main);
```

# 使用模块化加载时，模块加载的顺序是怎样的，如果不知道，根据已有的知识，你觉得顺序应该是怎么样的

依赖管理、命名冲突

- CommonJS

- AMD：RequireJS

- CMD： SeaJS

AMD vs CMD :同样都是异步加载模块，依赖模块执行时机不同

AMD在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入`require`的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行

CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，**遇到`require`语句的时候才执行对应的模块**，这样模块的执行顺序和书写顺序是完全一致的

这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因

# 介绍一下你所了解的作用域链,作用域链的尽头是什么，为什么

# 一个Ajax建立的过程是怎样的，主要用到哪些状态码

``` js
// 创建Ajax对象
var xmlhttp = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');//三元操作
// 连接服务器
xmlhttp.open('get', 'test.txt', true);
// 发送请求send()
xmlhttp.send();
// 接收返回信息
xmlhttp.onreadystatechange = function(){
  if(xmlhttp.readyState==4 && xmlhttp.status==200){
      document.getElementById("￼myId").innerHTML=xmlhttp.responseText;
  }
}
```

XMLHTTPRequest.readyState

0 (未初始化) or (请求还未初始化)
1 (正在加载) or (已建立服务器链接)
2 (加载成功) or (请求已接受)
3 (交互) or (正在处理请求)
4 (完成) or (请求已完成并且响应已准备好)

# 说说你还知道的其他状态码，状态码的存在解决了什么问题

http状态码的核心作用是告诉客户端当前Web服务器的响应状态。所以HTTP状态码常用来判断和分析当前Web服务器的运行状况。

3开头 （请求被重定向）
这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。

# 知道语义化吗？说说你理解的语义化，如果是你，平时会怎么做来保证语义化

# 说说content-box和border-box，为什么看起来content-box更合理，但是还是经常使用border-box

# this 是什么？

this: 上下文对象

纯函数: window or undefined

对象方法: 对象本身

类构造函数/类实例方法:

  - 类构造函数: 实例

  - 类静态方法：构造函数

# get post put delete

这样理解：url描述了一个网络上资源，而post、get、put、delete就是对这个资源进行增、删、改、查的操作

put请求：与GET不同的是，PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。

# 跨域通信方案

- JSONP

- WebSocket： 是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。

- CORS

CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求

# 函数防抖 & 函数节流

防抖: debounce 策略的电梯。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。

节流: throttle 策略的电梯。保证如果电梯第一个人进来后，15秒后准时运送一次，不等待。如果没有人，则待机。

# xss 脚本注入

# CSRF：又称XSRF，冒充用户发起请求

防范：验证码 token 来源检测

# css3动画与jquery动画

``` js
let requestFrame = (function () {
  return window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    function (callback) {
      // 60赫兹
      window.setTimeout(callback, 1000 / 60)
    }
})()
```

1.css3中的过渡和animation动画都是基于css实现机制的，属于css范畴之内，并没有涉及到任何语言操作。效率略高与jQuery中的animate()函数，但兼容性很差。

2.jQuery中的animate()函数可以简单的理解为css样式的“逐帧动画”，是css样式不同状态的快速切换的结果。效率略低于css3动画执行效率，但是兼容性好。

# 分域名请求图片

浏览器的并发请求数目限制是针对同一域名的，超过限制数目的请求会被阻塞

浏览器并发请求有个数限制，分域名可以同时并发请求大量图片

# 页面加载顺序

html顺序加载，其中js会阻塞后续dom和资源的加载，css不会阻塞dom和资源的加载但是会阻塞js的加载。

浏览器会使用prefetch对引用的资源提前下载

1.没有 defer 或 async，浏览器会立即加载并执行指定的脚本
2.有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行(下载异步，执行同步，加载完就执行)。
3.有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。

# 性能优化 css js分离

CSS 不会阻塞 DOM 的解析

浏览器是解析DOM生成DOM Tree，结合CSS生成的CSS Tree，最终组成render tree，再渲染页面。由此可见，在此过程中CSS完全无法影响DOM Tree，因而无需阻塞DOM解析。然而，DOM Tree和CSS Tree会组合成render tree，那CSS会不会页面阻塞渲染呢？

阻塞了页面解析其实是JS

JS在等待CSS的下载，然而这些等待的时间是完全不必要的

JS 阻塞 DOM 解析

对此的优化其实也很显而易见，具体分为两类。如果JS文件体积太大，同时你确定没必要阻塞DOM解析的话，不妨按需要加上defer或者async属性，此时脚本下载的过程中是不会阻塞DOM解析的。

**总结**

CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染。

JS 阻塞 DOM 解析

CSS文件的加载不影响js文件的加载，但是却影响js文件的执行，即使js文件内只有一行代码，也会造成阻塞。

浏览器遇到 <script>且没有defer或async属性的 标签时，会触发页面渲染，因而如果前面CSS资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。

所以，你现在明白为何<script>最好放底部，<link>最好放头部，如果头部同时有<script>与<link>的情况下，最好将<script>放在<link>上面

# 介绍一下你知道的浏览器缓存，分哪几种，通过什么方式实现，各有什么优缺点，有那些坑要注意

1. 强缓存

- `Expires`：返回的一个绝对时间

在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。

- `Cache-Control`：相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000

非覆盖式发布: 用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件

2. 协商缓存

- `Last-Modified`，`If-Modified-Since`：最后修改时间

- `ETag`、`If-None-Match` 原理：资源唯一标识

# 介绍一下HTML5的新特性，怎么理解这些新特性

# 平时关注新技术吗，通过哪些渠道，怎么看待新技术

# 任意连续的三个正整数相乘，一定能被6整除吗，为什么

必定存在一个是3的倍数，所以能被3整除
必定存在一个是2的倍数，所以一定是偶数

# 知道常用的数据结构有哪些

常用的数据结构：数组，队列（queue），堆（heap）,栈（stack），链表（linked list ），树（tree），图（graph）和散列表（hash）

js内置了Array和object。

  - Array可以当成多种数据结构用。常见的如：

  - 可变长的普通数组

  - tuple（固定长度的短数组）

  - stack 栈（push/pop）： 运算只在表的一端进行

  - queue 队列（push/shift 或 unshift/pop）： 运算只在表的两端进行，只允许在一端进行插入操作，而在另一端进行删除操作的线性表， 队列是一种先进先出（First In First Out, FIFO）的线性表

- plain object

可当成Record使用，也可当作`Map<string, any>`使用。

- linked list & tree: 基于object很容易做出简单的 linked list 或 tree 的结构。

ES6 增加了 Typed Array 和 ArrayBuffer，可以视作连续的内存块。

ES6 还增加了 Map、Set、WeakMap、WeakSet 等数据结构。未来 JS 可能会支持基于 ArrayBuffer 的 Struct。


# flex

flex属性是 flex-grow, flex-shrink 和 flex-basis的简写

flex-grow 属性定义项目的放大比例，默认为0

flex-shrink 属性定义了项目的缩小比例，默认为1

flex-basis 属性定义了项目的固定空间

# 语义化

title为页面的标题，一般书写在头部，显示在选项卡中，搜索引擎的快照中，概括了整个页面的内容，而h1是一级标题，修饰文章之用，对于一个页面来说，最好只有一个h1，多个h1会造成表达主体不明确

web标准主张html不涉及表现样式

b（bold）代表字体加粗，web标准主张html不涉及表现样式，因此b标签被废弃。strong标签代表逻辑上的强调，逻辑上的强调是通过字体加粗来实现的。总的来说，两个标签表现上都是将字体加粗，但是b标签意在样式，strong标签意在逻辑。

i与em的区别类似与b与strong的区别。虽然i与em均表现为斜体文字，但是em表达局部强调（strong是全局强调），i标签缺乏语义化

# visibilitychange

visibilitychange事件监听，视频或音频对用户不可见时，停止播放。

# 说说你对数据可视化的理解，和普通的WEB开发有什么不同

# 数据可视化的常用工具

数据可视化的常用工具有哪些

数据分析和数据挖掘的常用方法有哪些

如果给你一个四维一亿条数据，如何找出其中关联性比较大的几条数据

如果让你设计一个展示人际关系网的可视化界面，你会怎么设计，依据是什么

如果让你设计一个展示某个地区包裹存留数量的可视化界面，你会怎么设计，依据是什么

如果要表示密集性，你觉得可以通过哪些方式来表示

如果要表示层次性，你觉得可以通过哪些方式来表示

你是怎么协调团队项目的，你觉得要注意哪些问题

你在团队项目中遇到过最大的难题是什么，怎么解决的


https://github.com/tonyzheng1990/tonyzheng1990.github.io/issues/3

https://ovenzeze.github.io/a-phone-interview-of-aliyun/
