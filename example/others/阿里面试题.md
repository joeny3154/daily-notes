
https://github.com/tonyzheng1990/tonyzheng1990.github.io/issues/3

https://ovenzeze.github.io/a-phone-interview-of-aliyun/
# webpack import vs require

webpack 2 支持原生的 ES6 模块语法，意味着你可以无须额外引入 babel 这样的工具，就可以使用 import 和 export。但是注意，如果使用其他的 ES6+ 特性，仍然需要引入 babel。

通过 import 以静态的方式，导入另一个通过 export 导出的模块

由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构
`import { 'f' + 'oo' } from 'my_module';`会报错， 而require可以

import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中

这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。

const path = './' + fileName;
const myModual = require(path);
上面的语句就是动态加载，require到底加载哪一个模块，只有运行时才知道。

import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。

import 规范不允许控制模块的名称或其他属性，因为 "chunks" 只是 webpack 中的一个概念。幸运的是，webpack 中可以通过注释接收一些特殊的参数，而无须破坏规定

``` js
import(
  /* webpackChunkName: "my-chunk-name" */
  /* webpackMode: "lazy" */
  'module'
);
```
`webpackChunkName`：新 chunk 的名称。从 webpack 2.6.0 开始，[index] and [request] 占位符，分别支持赋予一个递增的数字和实际解析的文件名。
`webpackMode`：从 webpack 2.6.0 开始，可以指定以不同的模式解析动态导入。支持以下选项
https://doc.webpack-china.org/api/module-methods/#import

require: 以同步的方式检索其他模块的导出。由编译器(compiler)来确保依赖项在最终输出 bundle 中可用。

# Vue双向数据绑定的实现

vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的

`Object.defineProperty( )`设置了对象的属性，对其get和set进行重写操作

1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。

2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。

3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器

https://www.cnblogs.com/canfoo/p/6891868.html

vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者（文本节点则是作为订阅者），在收到消息后执行相应的更新操作。

compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

# react和vue有哪些不同 说说你对这两个框架的看法

Virtual DOM：改变真实的DOM状态远比改变一个JavaScript对象的花销要大得多

计算新旧Virtual DOM之间的差异并反应在真实的DOM上。计算差异的算法是高性能框架的秘密所在，React和Vue在实现上有点不同。

首先，内部实现本质上不同。React 的渲染建立在 Virtual DOM 上——一种在内存中描述 DOM 树状态的数据结构。当状态发生变化时，React 重新渲染 Virtual DOM，比较计算之后给真实 DOM 打补丁。

**Virtual DOM**

React 的 Virtual DOM 也不是不需要优化的。复杂的应用里你有两个选择：

1. 手动添加 `shouldComponentUpdate` 来避免不需要的 vdom re-render；2. Components 尽可能都用 pureRenderMixin，然后采用 Flux 结构 + Immutable.js。其实也不是那么简单的。

相比之下，Vue 由于采用依赖追踪，默认就是优化状态：你动了多少数据，就触发多少更新，不多也不少。

**双向绑定**

表单的双向绑定，说到底不过是 （value 的单向绑定 + onChange 事件侦听）的一个语法糖

JSX 在逻辑表达能力上虽然完爆模板

React 的另一个问题是：由于 DOM 更新完全交给 Virtual DOM 管理，当想要自己控制 DOM 时就有点棘手了（虽然理论上可以做到，但是这样做就本质上违背了 React 的设计思想）。如果应用需要特别的自定义 DOM 操作，特别是复杂时间控制的动画，这个限制就很讨厌。在这方面，Vue.js 更灵活。

**状态变更**

而在Vue中，则不需要使用如`setState()`之类的方法去改变它的状态，在Vue对象中，data参数就是应用中数据的保存者。

**vs 传统**

如果你的应用中，交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意，如果你更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM

# 平时用了es6的哪些特性，体验如何

- 箭头函数: 

- class语法: 相对原型、构造函数、继承更接近传统语法，它的写法能够让对象原型的写法更加清晰、面向对象编程的语法更加通俗

# let、const 区别

实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动

- ES6 声明变量的六种方法

ES5 只有两种声明变量的方法：var命令和function命令。

ES6 除了添加let和const命令，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。

- set数据结构：类似于数组，但是成员值都是唯一的

- 模板字符串

- rest参数: 获取函数的多余参数

`function add(...rest) {}`

- module


# 修饰器

类修饰器：修饰器是一个对类进行处理的函数， 修饰器函数的第一个参数，就是所要修饰的目标类。

方法的修饰：`readonly(Person.prototype, 'name', descriptor);`修饰器第一个参数是类的原型对象

# 浏览器原生支持module吗，如果支持，会带来哪些便利

- 运行时加载

``` js
// CommonJS模块
let { stat, exists, readFile } = require('fs');

// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
```
面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。

- 编译时加载/静态加载

``` js
// ES6模块
import { stat, exists, readFile } from 'fs';
```

上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。

# 介绍一下你对webpack的理解，和gulp有什么不同

webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。

gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。

虽然都是前端自动化构建工具，但看他们的定位就知道不是对等的。
gulp严格上讲，模块化不是他强调的东西，他旨在规范前端开发流程。
webpack更是明显强调模块化开发，而那些文件压缩合并、预处理等功能，不过是他附带的功能。

# webpack打包速度慢，你觉得可能的原因是什么，该如何解决

模块过多

- 开发环境不做无意义的操作

代码压缩、目录内容清理、计算文件hash、提取CSS文件

很多配置，在开发阶段是不需要去做的，我们可以区分出开发和线上的两套配置

- 选择一个合适的devtool属性值

`eval-source-map`（vue-cli dev配置使用此项选）每个模块使用 eval() 执行，并且 SourceMap 转换为 DataUrl 后添加到 eval() 中。初始化 SourceMap 时比较慢，但是会在重构建时提供很快的速度，并且生成实际的文件。行数能够正确映射，因为会映射到原始代码中。

- happypack 多线程打包

利用node提供的多线程环境，happypack 是可以多线程打包的
采用多进程去打包构建，使用方式还是蛮简单的，但并不是支持所有的loader

- dll打包

需要两个插件 DllPlugin 和 DllReferencePlugin， Dll是动态链接库的意思，实际上就是将这些npm打包生成一个JSON文件，这个文件里包含了npm包的路径对应信息

- babel-loader开启缓存

# http响应中`content-type`包含哪些内容

指定返回内容的类型，主要包括住类型/子类型

- text

text/html ： HTML格式
text/plain ：纯文本格式
text/xml ： XML格式

- image

image/gif ：gif图片格式
image/jpeg ：jpg图片格式
image/png：png图片格式
以application开头的媒体格

- application

以application开头的媒体格式类型：
application/xhtml+xml ：XHTML格式
application/xml ： XML数据格式
application/atom+xml ：Atom XML聚合格式
application/json ： JSON数据格式
application/pdf ：pdf格式
application/msword ： Word文档格式
application/octet-stream ： 二进制流数据（如常见的文件下载）
application/x-www-form-urlencoded 

# 浏览器缓存有哪些，通常缓存有哪几种方式

# 如何取出一个数组里的图片并按顺序显示出来

# 平时是怎么学新技术的

# Node，Koa用的怎么样


使用模块化加载时，模块加载的顺序是怎样的，如果不知道，根据已有的知识，你觉得顺序应该是怎么样的

介绍一下闭包和闭包常用场景

为什么会出现闭包这种东西，解决了什么问题

介绍一下你所了解的作用域链,作用域链的尽头是什么，为什么

一个Ajax建立的过程是怎样的，主要用到哪些状态码

说说你还知道的其他状态码，状态码的存在解决了什么问题

知道语义化吗？说说你理解的语义化，如果是你，平时会怎么做来保证语义化

说说content-box和border-box，为什么看起来content-box更合理，但是还是经常使用border-box

介绍一下你知道的浏览器缓存，分哪几种，通过什么方式实现，各有什么优缺点，有那些坑要注意


说说你对数据可视化的理解，和普通的WEB开发有什么不同

知道常用的数据结构有哪些

数据可视化的常用工具有哪些

数据分析和数据挖掘的常用方法有哪些

如果给你一个四维一亿条数据，如何找出其中关联性比较大的几条数据

如果让你设计一个展示人际关系网的可视化界面，你会怎么设计，依据是什么

如果让你设计一个展示某个地区包裹存留数量的可视化界面，你会怎么设计，依据是什么

如果要表示密集性，你觉得可以通过哪些方式来表示

如果要表示层次性，你觉得可以通过哪些方式来表示

你是怎么协调团队项目的，你觉得要注意哪些问题

你在团队项目中遇到过最大的难题是什么，怎么解决的

介绍一下HTML5的新特性，怎么理解这些新特性

平时关注新技术吗，通过哪些渠道，怎么看待新技术

任意连续的三个正整数相乘，一定能被6整除吗，为什么
