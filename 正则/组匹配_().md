

组匹配
=======

正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。

```
/fred+/.test('fredd') // true
/(fred)+/.test('fredfred') // true

```
第一个模式没有括号，结果+只表示重复字母d，第二个模式有括号，结果+就表示匹配“fred”这个词。

**分组匹配**

```
var m = 'abcabv'.match(/(.)b(.)/);
m // ['abc', 'a', 'c']

<!-- 使用g修饰符，否则match方法不会捕获分组的内容 -->
var m = 'abcabv'.match(/(.)b(.)/g);
m // ['abc', 'abv']
```

**使用 (`\n`)引用匹配内容**

在正则表达式内部，可以用`\n`引用括号匹配的内容，`n`是从1开始的自然数，表示对应顺序的括号:

```
/(.)b(.)d\2b\1/.test("abcdcba") // true
```

括号还可以嵌套:

```
<!-- 上面代码中，\1指向外层括号，\2指向内层括号 -->
/y((..)\2)\1/.test('yabababab') // true
```

组匹配非常有用，下面是一个匹配网页标签的例子:

eg: 

```
var tagName = /<(\w+)[^>]*>.*?<\/\1>/;
tagName.exec('<b class="a" style="width: 300px;">bold</b>')[1]
```

- 非捕获组 (不计入匹配)

`(?:x)`称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。

场景：取消不必要的组匹配占用

/(foo){1, 2}/ => /(?:foo){1, 2}/

```
var m = 'abc'.match(/(?:.)b(.)/);
m //["abc", "a", "c", index: 0, input: "abc"]

var m = 'abc'.match(/(?:.)b(.)/);
m // ["abc", "c", index: 0, input: "abc"]
```

- 先行断言

`x(?=y)`称为先行断言（Positive look-ahead），`x`只有在`y`前面才匹配，`y`不会被计入返回结果。

要匹配后面跟着百分号的数字，可以写成:`/\d+(?=%)/`

*“先行断言”中，括号里的部分是不会返回的*

- 先行否定断言

x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果

要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/

```
/\d+(?!\.)/.exec('3.14')
// ["14"]
```

**“先行断言”中，括号里的部分是不会返回的**
```
var m = 'abd'.match(/b(?!c)/); // ['b']
```
上面的代码使用了先行否定断言，b不在c前面所以被匹配，而且括号对应的**d不会被返回**。